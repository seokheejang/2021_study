# lesson 1
## 상태 변수
상태 변수는 컨트랙트 저장소에 영구적으로 저장, 이더리움 블록체인(Global DB)에 기록
```
contract Example {
  // 이 변수는 블록체인에 영구적으로 저장된다
  uint myUnsignedInteger = 100;
}
```
> 참고: 솔리디티에서 uint는 실제로 uint256, 즉 256비트 부호 없는 정수의 다른 표현. uint8, uint16, uint32 등과 같이 uint를 더 적은 비트로 선언할 수도 있다. 이 강의에서는 특수한 경우가 아니라면 일반적으로 단순히 uint를 사용함.

## 구조체
```
struct Person {
  uint age;
  string name;
}
```

## 배열
솔리디티에는 _정적_ 배열과 _동적_ 배열이라는 두 종류의 배열이 존재
```
// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;
```

### Public 배열
```
Person[] public people;
```
솔리디티는 이런 배열을 위해 getter 메소드를 자동적으로 생성. 다른 컨트랙트에 공개 데이터를 저장할 때 유용한 패턴.

## 함수 선언
```
function eatHamburgers(string _name, uint _amount) {

}
```
> 참고: 함수 인자명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례(의무는 아님).
```
// 위 선언한 함수를 다음과 같이 호출 
eatHamburgers("vitalik", 100); 
```

## 구조체와 배열 활용
```
// 새로운 사람을 생성한다:
Person satoshi = Person(172, "Satoshi");

// 이 사람을 배열에 추가한다:
people.push(satoshi);

// 위 두 코드를 조합하면 한 줄로도 표현 가능
people.push(Person(16, "Vitalik"));
```
array.push()는 무언가를 배열의 끝에 추가하여 모든 원소가 순소를 유지하도록 함.
```
uint[] numbers;
numbers.push(5);
numbers.push(10);
numbers.push(15);
// numbers 배열은 [5, 10, 15]과 같다.
```

## Private/Public 함수
솔리디티에서 함수는 기본적으로 public으로 선언. 즉, 누구나 (혹은 다른 어느 컨트랙트가) 컨트랙트의 함수를 호출하고 코드를 실행할 수 있다는 의미이다.

하지만 보안적으로 취약하기 때문에 기본적으로 함수를 private로 선언하고, 공개할 함수만 public으로 선언하는 것을 추천.
```
uint[] numbers;

// private는 컨트랙트 내의 다른 함수들만이 이 함수를 호출하여 numbers 배열로 무언가를 추가할 수 있다는 것을 의미
function _addToArray(uint _number) private {
  numbers.push(_number);
}
```
> 함수 인자명과 마찬가지로 private 함수명도 언더바(_)로 시작하는 것이 관례

## 추가 함수 내용
### return value
```
string greeting = "What's up dog";

function sayHello() public returns (string) { // 솔리디티에서 함수 선언은 반환값 종류를 포함
  return greeting;
}
```
### 함수 제어자
위 sayHello() 함수의 경우 어떤 값을 변경하지 않는다. 이럴 경우 view 함수로 선언한다.
```
function sayHello() public view returns (string) {
}
```
추가로 솔리디티는 pure 함수란 개념이 있는데 이는 함수가 앱에서 어떤 데이터도 접근하지 않는 것을 의미한다.
```
function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}
```
이 함수는 view하지 않고 return 값이 함수에 전달된 인자에 따라 달라진다. 이런 경우가 pure 함수
> 참고: 함수를 pure나 view로 언제 표시할지 기억하기 어려울 수 있다. 운 좋게도 솔리디티 컴파일러는 어떤 제어자를 써야 하는지 경고 메시지를 통해 잘 알려준다.

## Keccak256과 형 변환
이더리움은 SHA3의 한 버전인 keccak256를 내장 해시 함수로 가지고 있다. 해시 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑한다.
 * keccak256: 공개 키를 추출하기 위한 해시 알고리즘, 생성된 해시 값의 마지막 20자리가 이더리움 address

 해시 함수는 이더리움에서 여러 용도로 활용되지만, 여기서는 의사 난수 발생기(pseudo-random number generator)로 이용한 예시
 ```
 //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256("aaaab");
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256("aaaac");
```
이 예시를 보면 입력값의 한 글자가 달라졌음에도 불구하고 반환값은 완전히 달라짐을 확인

> 참고: 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제이다. 여기서 활용한 방법은 안전하지는 않지만, 좀비 DNA에 있어서 보안은 최우선순위가 아니니 우리의 목적에는 충분히 적합할 것.

### 형 변환
```
uint8 a = 5;
uint b = 6;
// a * b가 uint8이 아닌 uint를 반환하기 때문에 에러 메시지가 난다:
uint8 c = a * b; 
// b를 uint8으로 형 변환해서 코드가 제대로 작동하도록 해야 한다:
uint8 c = a * uint8(b); 
```

## 이벤트
이벤트는 자네의 컨트랙트가 블록체인 상에서 자네 앱의 사용자 단에서 무언가 액션이 발생했을 때 의사소통하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는지 "귀를 기울이고" 그 이벤트가 발생하면 행동을 취한다.
```
// 이벤트를 선언한다
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다:
  IntegersAdded(_x, _y, result);
  return result;
}
```

그러면 앱의 사용자 단은 해당 이벤트가 일어나는지 귀를 기울인다. 자바스크립트로 이를 구현하면 다음과 같음:
```js
YourContract.IntegersAdded(function(error, result) {
  // 결과와 관련된 행동을 취한다
})
```

## Web3.js
이더리움은 Web3.js라고 하는 자바스크립트 라이브러리를 가지고 통신이 가능
```js
// 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.

// 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
  ZombieFactory.createRandomZombie(name)
})

// `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// 좀비 DNA 값을 받아서 이미지를 업데이트한다
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
    // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
    // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 셔츠 타입에는 6가지가 있다:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}
```
위 코드로 생성한 lesson 1 크립토 좀비

https://share.cryptozombies.io/ko/lesson/1/share/shjang

## 학습 예제
```
pragma solidity ^0.4.19;

contract ZombieFactory {

    event NewZombie(uint zombieId, string name, uint dna);

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }

    Zombie[] public zombies;

    function _createZombie(string _name, uint _dna) private {
        uint id = zombies.push(Zombie(_name, _dna)) - 1;
        NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
    }

    function createRandomZombie(string _name) public {
        uint randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }

}
```